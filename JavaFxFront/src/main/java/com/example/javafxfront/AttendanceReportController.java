package com.example.javafxfront;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import java.io.File;
import java.io.FileWriter;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Kontroler dziennika obecnoÅ›ci (attendance-report-view.fxml).
 *
 * <p>AttendanceReportController zarzÄ…dza widokiem raportu frekwencji,
 * wyÅ›wietlajÄ…c szczegÃ³Å‚owe dane obecnoÅ›ci studentÃ³w w formie tabeli
 * oraz generujÄ…c statystyki i umoÅ¼liwiajÄ…c eksport danych do pliku CSV.</p>
 *
 * <p>Kontroler oferuje kompleksowy system raportowania obecnoÅ›ci z nastÄ™pujÄ…cymi funkcjonaloÅ›ciami:</p>
 *
 * <h3>GÅ‚Ã³wne funkcjonalnoÅ›ci:</h3>
 * <ul>
 *   <li><strong>Dynamiczna tabela obecnoÅ›ci</strong> - automatyczne tworzenie kolumn dla kaÅ¼dego terminu</li>
 *   <li><strong>Kolorowe oznaczenia statusÃ³w</strong> - wizualne rozrÃ³Å¼nienie obecnych/spÃ³Åºnionych/nieobecnych</li>
 *   <li><strong>Statystyki frekwencji</strong> - obliczanie Å›redniej obecnoÅ›ci, najlepszego i najgorszego studenta</li>
 *   <li><strong>System filtrowania</strong> - filtrowanie wedÅ‚ug terminÃ³w i statusÃ³w obecnoÅ›ci</li>
 *   <li><strong>Eksport do CSV</strong> - zachowanie peÅ‚nej struktury danych w formacie arkusza</li>
 *   <li><strong>Responsywny design</strong> - automatyczne dostosowanie kolumn do zawartoÅ›ci</li>
 * </ul>
 *
 * <h3>Struktura raportu:</h3>
 * <p>Raport prezentuje dane w nastÄ™pujÄ…cym ukÅ‚adzie:</p>
 * <ul>
 *   <li><strong>NagÅ‚Ã³wek</strong> - informacje o grupie, liczbie studentÃ³w i terminÃ³w</li>
 *   <li><strong>Filtry</strong> - moÅ¼liwoÅ›Ä‡ zawÄ™Å¼enia widoku raportu</li>
 *   <li><strong>Statystyki</strong> - kluczowe wskaÅºniki frekwencji grupy</li>
 *   <li><strong>Tabela gÅ‚Ã³wna</strong> - macierz student Ã— termin z statusami obecnoÅ›ci</li>
 *   <li><strong>Kolumna statystyk</strong> - podsumowanie dla kaÅ¼dego studenta</li>
 * </ul>
 *
 * <h3>Kolorowanie statusÃ³w:</h3>
 * <ul>
 *   <li><span style="color: #38A169;">ğŸŸ¢ Obecny</span> - zielone tÅ‚o</li>
 *   <li><span style="color: #F56500;">ğŸŸ¡ SpÃ³Åºniony</span> - pomaraÅ„czowe tÅ‚o</li>
 *   <li><span style="color: #E53E3E;">ğŸ”´ Nieobecny</span> - czerwone tÅ‚o</li>
 *   <li><span style="color: #6C757D;">âšª Nie zaznaczono</span> - szare tÅ‚o</li>
 * </ul>
 *
 * <h3>PrzykÅ‚ad uÅ¼ycia:</h3>
 * <pre>
 * {@code
 * // Otwieranie raportu z kontrolera grupy
 * FXMLLoader loader = new FXMLLoader(getClass().getResource("attendance-report-view.fxml"));
 * Parent root = loader.load();
 *
 * AttendanceReportController reportController = loader.getController();
 * reportController.setData(currentGroup, studentsList, schedulesList);
 *
 * Stage reportStage = new Stage();
 * reportStage.setTitle("ğŸ“Š Dziennik obecnoÅ›ci - " + currentGroup.getName());
 * reportStage.setScene(new Scene(root, 1200, 800));
 * reportStage.show();
 * }
 * </pre>
 *
 * <h3>Obliczenia statystyczne:</h3>
 * <p>Kontroler automatycznie oblicza nastÄ™pujÄ…ce wskaÅºniki:</p>
 * <ul>
 *   <li><strong>Åšrednia obecnoÅ›Ä‡ grupy</strong> - procent obecnoÅ›ci wszystkich studentÃ³w</li>
 *   <li><strong>Najlepsza frekwencja</strong> - student z najwyÅ¼szym procentem obecnoÅ›ci</li>
 *   <li><strong>Najgorsza frekwencja</strong> - student z najniÅ¼szym procentem obecnoÅ›ci</li>
 *   <li><strong>Statystyki indywidualne</strong> - procent obecnoÅ›ci dla kaÅ¼dego studenta</li>
 * </ul>
 *
 * @author System Team
 * @version 1.0
 * @since 2024
 *
 * @see GroupDetailController
 * @see Attendance
 * @see AttendanceReportRow
 * @see Group
 * @see Student
 * @see ClassSchedule
 */
public class AttendanceReportController {

    // Elementy nagÅ‚Ã³wka raportu

    /**
     * Label wyÅ›wietlajÄ…cy nazwÄ™ grupy w nagÅ‚Ã³wku raportu.
     *
     * <p>Format: "Grupa: [nazwa_grupy]"</p>
     */
    @FXML private Label groupNameLabel;

    /**
     * GÅ‚Ã³wny tytuÅ‚ raportu.
     *
     * <p>Format: "Dziennik obecnoÅ›ci - [nazwa_grupy]"</p>
     */
    @FXML private Label reportTitleLabel;

    /**
     * Label pokazujÄ…cy liczbÄ™ studentÃ³w w grupie.
     *
     * <p>Format: "Liczba studentÃ³w: X"</p>
     */
    @FXML private Label totalStudentsLabel;

    /**
     * Label pokazujÄ…cy liczbÄ™ terminÃ³w w raporcie.
     *
     * <p>Format: "Liczba terminÃ³w: X"</p>
     */
    @FXML private Label totalSchedulesLabel;

    // GÅ‚Ã³wna tabela obecnoÅ›ci

    /**
     * GÅ‚Ã³wna tabela raportu obecnoÅ›ci.
     *
     * <p>Tabela zawiera:</p>
     * <ul>
     *   <li>Kolumny staÅ‚e: ImiÄ™ i nazwisko, Nr indeksu</li>
     *   <li>Kolumny dynamiczne: jedna dla kaÅ¼dego terminu zajÄ™Ä‡</li>
     *   <li>Kolumna statystyk: podsumowanie dla studenta</li>
     * </ul>
     *
     * <p>KaÅ¼da komÃ³rka z obecnoÅ›ciÄ… jest kolorowana wedÅ‚ug statusu.</p>
     */
    @FXML private TableView<AttendanceReportRow> attendanceTable;

    /**
     * Kolumna z imieniem i nazwiskiem studenta.
     *
     * <p>SzerokoÅ›Ä‡: 200px, sortowalna alfabetycznie.</p>
     */
    @FXML private TableColumn<AttendanceReportRow, String> studentNameColumn;

    /**
     * Kolumna z numerem indeksu studenta.
     *
     * <p>SzerokoÅ›Ä‡: 100px, sortowalna numerycznie.</p>
     */
    @FXML private TableColumn<AttendanceReportRow, String> indexColumn;

    // Statystyki

    /**
     * Label wyÅ›wietlajÄ…cy Å›redniÄ… obecnoÅ›Ä‡ wszystkich studentÃ³w.
     *
     * <p>Format: "X.X%" gdzie X.X to procent z jednym miejscem po przecinku.</p>
     */
    @FXML private Label avgAttendanceLabel;

    /**
     * Label pokazujÄ…cy studenta z najlepszÄ… frekwencjÄ….
     *
     * <p>Format: "ImiÄ™ Nazwisko (X.X%)" gdzie X.X to procent obecnoÅ›ci.</p>
     */
    @FXML private Label bestStudentLabel;

    /**
     * Label pokazujÄ…cy studenta z najgorszÄ… frekwencjÄ….
     *
     * <p>Format: "ImiÄ™ Nazwisko (X.X%)" gdzie X.X to procent obecnoÅ›ci.</p>
     */
    @FXML private Label worstStudentLabel;

    // Przyciski akcji

    /**
     * Przycisk eksportu dziennika do pliku CSV.
     *
     * <p>Otwiera dialog wyboru pliku i zapisuje peÅ‚nÄ… tabelÄ™ obecnoÅ›ci
     * w formacie CSV zachowujÄ…c strukturÄ™ kolumn i wszystkie dane.</p>
     */
    @FXML private Button exportCSVButton;

    /**
     * Przycisk zamykajÄ…cy okno dziennika.
     */
    @FXML private Button closeButton;

    /**
     * Przycisk odÅ›wieÅ¼ajÄ…cy raport.
     *
     * <p>Regeneruje tabelÄ™ i przelicza statystyki na podstawie aktualnych danych.</p>
     */
    @FXML private Button refreshButton;

    // Filtry

    /**
     * ComboBox do filtrowania wedÅ‚ug terminÃ³w.
     *
     * <p>Zawiera opcje:</p>
     * <ul>
     *   <li>"Wszystkie terminy" - brak filtrowania</li>
     *   <li>Nazwy konkretnych terminÃ³w z datami</li>
     * </ul>
     */
    @FXML private ComboBox<String> filterScheduleComboBox;

    /**
     * ComboBox do filtrowania wedÅ‚ug typu obecnoÅ›ci.
     *
     * <p>Wykorzystuje enum {@link AttendanceFilter} do okreÅ›lenia rodzaju filtra.</p>
     */
    @FXML private ComboBox<AttendanceFilter> filterTypeComboBox;

    // Dane

    /**
     * Referencja do bieÅ¼Ä…cej grupy dla ktÃ³rej generowany jest raport.
     */
    private Group currentGroup;

    /**
     * Lista studentÃ³w grupy do uwzglÄ™dnienia w raporcie.
     */
    private List<Student> students;

    /**
     * Lista terminÃ³w zajÄ™Ä‡ do uwzglÄ™dnienia w raporcie.
     */
    private List<ClassSchedule> schedules;

    /**
     * Serwis obsÅ‚ugi obecnoÅ›ci do dodatkowych operacji na danych.
     */
    private AttendanceService attendanceService;

    /**
     * Observable lista wierszy raportu zwiÄ…zana z tabelÄ… JavaFX.
     *
     * <p>KaÅ¼dy element reprezentuje jednego studenta z jego obecnoÅ›ciami
     * na wszystkich terminach oraz obliczonymi statystykami.</p>
     */
    private ObservableList<AttendanceReportRow> reportData;

    /**
     * Wyliczenie typÃ³w filtrÃ³w dla dziennika obecnoÅ›ci.
     *
     * <p>UmoÅ¼liwia zawÄ™Å¼enie widoku raportu do konkretnych kategorii obecnoÅ›ci.
     * KaÅ¼dy typ filtru ma przypisanÄ… nazwÄ™ wyÅ›wietlanÄ… w interfejsie uÅ¼ytkownika.</p>
     *
     * <h3>DostÄ™pne filtry:</h3>
     * <ul>
     *   <li><strong>ALL</strong> - pokazuje wszystkich studentÃ³w</li>
     *   <li><strong>PRESENT_ONLY</strong> - tylko studentÃ³w oznaczonych jako obecni</li>
     *   <li><strong>ABSENT_ONLY</strong> - tylko studentÃ³w oznaczonych jako nieobecni</li>
     *   <li><strong>LATE_ONLY</strong> - tylko studentÃ³w oznaczonych jako spÃ³Åºnieni</li>
     * </ul>
     *
     * @see #filterTypeComboBox
     * @see #applyFilters()
     */
    public enum AttendanceFilter {
        /** Pokazuje wszystkie wpisy obecnoÅ›ci bez filtrowania */
        ALL("Wszystkie"),

        /** Filtruje tylko studentÃ³w obecnych na zajÄ™ciach */
        PRESENT_ONLY("Tylko obecni"),

        /** Filtruje tylko studentÃ³w nieobecnych na zajÄ™ciach */
        ABSENT_ONLY("Tylko nieobecni"),

        /** Filtruje tylko studentÃ³w spÃ³Åºnionych na zajÄ™cia */
        LATE_ONLY("Tylko spÃ³Åºnieni");

        /** Nazwa wyÅ›wietlana filtru w interfejsie uÅ¼ytkownika */
        private final String displayName;

        /**
         * Konstruktor typu filtru.
         *
         * @param displayName nazwa do wyÅ›wietlenia w ComboBox
         */
        AttendanceFilter(String displayName) {
            this.displayName = displayName;
        }

        /**
         * Zwraca nazwÄ™ wyÅ›wietlanÄ… filtru.
         *
         * @return nazwa filtru do pokazania uÅ¼ytkownikowi
         */
        public String getDisplayName() {
            return displayName;
        }

        /**
         * Zwraca nazwÄ™ wyÅ›wietlanÄ… jako reprezentacjÄ™ tekstowÄ….
         *
         * @return nazwa filtru (uÅ¼ywana przez ComboBox)
         */
        @Override
        public String toString() {
            return displayName;
        }
    }

    /**
     * Metoda inicjalizacyjna kontrolera wywoÅ‚ywana automatycznie przez JavaFX.
     *
     * <p>Konfiguruje wszystkie elementy interfejsu uÅ¼ytkownika, inicjalizuje serwisy
     * i ustawia nasÅ‚uchiwanie zdarzeÅ„. Ta metoda jest wywoÅ‚ywana automatycznie
     * po zaÅ‚adowaniu pliku FXML, ale przed przekazaniem danych przez {@link #setData(Group, List, List)}.</p>
     *
     * <p>Wykonywane operacje inicjalizacyjne:</p>
     * <ol>
     *   <li>Inicjalizacja serwisu obecnoÅ›ci i listy danych raportu</li>
     *   <li>Konfiguracja kolumn tabeli z PropertyValueFactory</li>
     *   <li>Ustawienie filtrÃ³w w ComboBox</li>
     *   <li>PowiÄ…zanie listy danych z tabelÄ…</li>
     *   <li>Konfiguracja akcji przyciskÃ³w</li>
     *   <li>Ustawienie nasÅ‚uchiwania zdarzeÅ„ filtrÃ³w</li>
     * </ol>
     *
     * <p>Po inicjalizacji kontroler jest gotowy do otrzymania danych
     * przez metodÄ™ {@link #setData(Group, List, List)}.</p>
     *
     * @see #setData(Group, List, List)
     * @see #setupTableColumns()
     * @see #setupFilters()
     */
    @FXML
    protected void initialize() {
        attendanceService = new AttendanceService();
        reportData = FXCollections.observableArrayList();

        setupTableColumns();
        setupFilters();

        attendanceTable.setItems(reportData);

        // Akcje przyciskÃ³w
        exportCSVButton.setOnAction(e -> exportToCSV());
        closeButton.setOnAction(e -> closeWindow());
        refreshButton.setOnAction(e -> refreshReport());

        // Filtry
        filterScheduleComboBox.setOnAction(e -> applyFilters());
        filterTypeComboBox.setOnAction(e -> applyFilters());
    }

    /**
     * Ustawia dane dla raportu obecnoÅ›ci i generuje kompletny raport.
     *
     * <p>GÅ‚Ã³wna metoda wywoÅ‚ywana przez kontroler nadrzÄ™dny ({@link GroupDetailController})
     * do przekazania danych grupy, studentÃ³w i terminÃ³w. Po otrzymaniu danych metoda
     * automatycznie inicjalizuje wszystkie elementy raportu i generuje kompletnÄ… tabelÄ™ oraz statystyki.</p>
     *
     * <p>Proces generowania raportu:</p>
     * <ol>
     *   <li>Zapisanie referencji do danych wejÅ›ciowych</li>
     *   <li>Aktualizacja informacji w nagÅ‚Ã³wku raportu</li>
     *   <li>Konfiguracja filtra terminÃ³w</li>
     *   <li>Generowanie gÅ‚Ã³wnej tabeli obecnoÅ›ci</li>
     *   <li>Obliczanie i wyÅ›wietlanie statystyk</li>
     * </ol>
     *
     * <p>Wymagania danych wejÅ›ciowych:</p>
     * <ul>
     *   <li><strong>group</strong> - musi zawieraÄ‡ poprawnÄ… nazwÄ™ i specjalizacjÄ™</li>
     *   <li><strong>students</strong> - lista moÅ¼e byÄ‡ pusta, ale nie null</li>
     *   <li><strong>schedules</strong> - lista moÅ¼e byÄ‡ pusta, ale nie null</li>
     * </ul>
     *
     * <p>PrzykÅ‚ad uÅ¼ycia:</p>
     * <pre>
     * {@code
     * // W kontrolerze grupy
     * AttendanceReportController reportController = loader.getController();
     *
     * // Przekazanie danych - raport zostanie automatycznie wygenerowany
     * reportController.setData(
     *     currentGroup,                    // grupa
     *     new ArrayList<>(students),       // kopia listy studentÃ³w
     *     new ArrayList<>(schedules)       // kopia listy terminÃ³w
     * );
     *
     * // Raport jest juÅ¼ gotowy do wyÅ›wietlenia
     * }
     * </pre>
     *
     * @param group grupa do raportu (nie moÅ¼e byÄ‡ null)
     * @param students lista studentÃ³w grupy (nie moÅ¼e byÄ‡ null, moÅ¼e byÄ‡ pusta)
     * @param schedules lista terminÃ³w zajÄ™Ä‡ (nie moÅ¼e byÄ‡ null, moÅ¼e byÄ‡ pusta)
     *
     * @throws IllegalArgumentException jeÅ›li ktÃ³rykolwiek z parametrÃ³w jest null
     *
     * @see #updateHeader()
     * @see #generateReport()
     * @see #calculateStatistics()
     * @see GroupDetailController#onShowReportClick()
     */
    public void setData(Group group, List<Student> students, List<ClassSchedule> schedules) {
        this.currentGroup = group;
        this.students = students;
        this.schedules = schedules;

        updateHeader();
        setupScheduleFilter();
        generateReport();
        calculateStatistics();
    }

    /**
     * Konfiguruje kolumny tabeli z podstawowymi PropertyValueFactory.
     *
     * <p>Ustawia fabryki wartoÅ›ci dla staÅ‚ych kolumn tabeli (imiÄ™/nazwisko i nr indeksu).
     * Dynamiczne kolumny dla terminÃ³w sÄ… dodawane pÃ³Åºniej w {@link #generateReport()}.</p>
     *
     * <p>Konfigurowane kolumny:</p>
     * <ul>
     *   <li><strong>studentNameColumn</strong> - powiÄ…zana z wÅ‚aÅ›ciwoÅ›ciÄ… "studentName"</li>
     *   <li><strong>indexColumn</strong> - powiÄ…zana z wÅ‚aÅ›ciwoÅ›ciÄ… "indexNumber"</li>
     * </ul>
     *
     * @see #generateReport()
     * @see AttendanceReportRow#getStudentName()
     * @see AttendanceReportRow#getIndexNumber()
     */
    private void setupTableColumns() {
        studentNameColumn.setCellValueFactory(new PropertyValueFactory<>("studentName"));
        indexColumn.setCellValueFactory(new PropertyValueFactory<>("indexNumber"));

        // Dynamiczne kolumny dla kaÅ¼dego terminu bÄ™dÄ… dodane w generateReport()
    }

    /**
     * Konfiguruje dostÄ™pne opcje filtrÃ³w w ComboBox.
     *
     * <p>Inicjalizuje ComboBox filtra typu obecnoÅ›ci wszystkimi dostÄ™pnymi opcjami
     * z enum {@link AttendanceFilter} i ustawia domyÅ›lnÄ… wartoÅ›Ä‡ na "Wszystkie".</p>
     *
     * @see AttendanceFilter
     * @see #applyFilters()
     */
    private void setupFilters() {
        filterTypeComboBox.setItems(FXCollections.observableArrayList(AttendanceFilter.values()));
        filterTypeComboBox.setValue(AttendanceFilter.ALL);
    }

    /**
     * Konfiguruje opcje filtra terminÃ³w na podstawie przekazanych danych.
     *
     * <p>WypeÅ‚nia ComboBox filtra terminÃ³w opcjÄ… "Wszystkie terminy" oraz
     * nazwami konkretnych terminÃ³w z datami. KaÅ¼dy termin jest reprezentowany
     * w formacie: "Nazwa przedmiotu (dd.MM.yyyy HH:mm)".</p>
     *
     * <p>Struktura opcji filtra:</p>
     * <ol>
     *   <li>"Wszystkie terminy" - opcja domyÅ›lna, brak filtrowania</li>
     *   <li>Lista terminÃ³w w formacie: "Przedmiot (data)"</li>
     * </ol>
     *
     * @see ClassSchedule#getSubject()
     * @see ClassSchedule#getFormattedStartTime()
     */
    private void setupScheduleFilter() {
        ObservableList<String> scheduleNames = FXCollections.observableArrayList();
        scheduleNames.add("Wszystkie terminy");

        for (ClassSchedule schedule : schedules) {
            scheduleNames.add(schedule.getSubject() + " (" + schedule.getFormattedStartTime() + ")");
        }

        filterScheduleComboBox.setItems(scheduleNames);
        filterScheduleComboBox.setValue("Wszystkie terminy");
    }

    /**
     * Aktualizuje informacje w nagÅ‚Ã³wku raportu.
     *
     * <p>WypeÅ‚nia labele w nagÅ‚Ã³wku raportu aktualnymi informacjami o grupie
     * i liczbie studentÃ³w oraz terminÃ³w. Wszystkie informacje sÄ… formatowane
     * do czytelnej prezentacji.</p>
     *
     * <p>Aktualizowane elementy:</p>
     * <ul>
     *   <li><strong>groupNameLabel</strong> - "Grupa: [nazwa]"</li>
     *   <li><strong>reportTitleLabel</strong> - "Dziennik obecnoÅ›ci - [nazwa]"</li>
     *   <li><strong>totalStudentsLabel</strong> - "Liczba studentÃ³w: X"</li>
     *   <li><strong>totalSchedulesLabel</strong> - "Liczba terminÃ³w: X"</li>
     * </ul>
     */
    private void updateHeader() {
        if (currentGroup != null) {
            groupNameLabel.setText("Grupa: " + currentGroup.getName());
            reportTitleLabel.setText("Dziennik obecnoÅ›ci - " + currentGroup.getName());
            totalStudentsLabel.setText("Liczba studentÃ³w: " + students.size());
            totalSchedulesLabel.setText("Liczba terminÃ³w: " + schedules.size());
        }
    }

    /**
     * Generuje gÅ‚Ã³wnÄ… tabelÄ™ raportu obecnoÅ›ci z dynamicznymi kolumnami.
     *
     * <p>To kluczowa metoda kontrolera, ktÃ³ra tworzy kompletnÄ… tabelÄ™ obecnoÅ›ci
     * z dynamicznie generowanymi kolumnami dla kaÅ¼dego terminu zajÄ™Ä‡. Metoda
     * czyÅ›ci istniejÄ…ce dane, dodaje kolumny dla terminÃ³w i wypeÅ‚nia wiersze
     * danymi wszystkich studentÃ³w.</p>
     *
     * <p>Proces generowania tabeli:</p>
     * <ol>
     *   <li>Wyczyszczenie danych i kolumn tabeli</li>
     *   <li>Dodanie podstawowych kolumn (ImiÄ™/Nazwisko, Nr indeksu)</li>
     *   <li>Dynamiczne tworzenie kolumn dla kaÅ¼dego terminu</li>
     *   <li>Konfiguracja stylizacji komÃ³rek z kolorowaniem statusÃ³w</li>
     *   <li>Dodanie kolumny statystyk</li>
     *   <li>WypeÅ‚nienie wierszy danymi studentÃ³w</li>
     *   <li>Zebranie obecnoÅ›ci dla kaÅ¼dego studenta na kaÅ¼dym terminie</li>
     *   <li>Obliczenie statystyk dla kaÅ¼dego studenta</li>
     * </ol>
     *
     * <p>Struktura kolumn w tabeli:</p>
     * <ul>
     *   <li><strong>ImiÄ™ i nazwisko</strong> - 200px szerokoÅ›ci</li>
     *   <li><strong>Nr indeksu</strong> - 100px szerokoÅ›ci</li>
     *   <li><strong>Kolumny terminÃ³w</strong> - dynamiczna szerokoÅ›Ä‡, jedna na termin</li>
     *   <li><strong>Statystyki</strong> - podsumowanie obecnoÅ›ci studenta</li>
     * </ul>
     *
     * <p>Kolorowanie komÃ³rek wedÅ‚ug statusu:</p>
     * <ul>
     *   <li><strong>Obecny</strong> - zielone tÅ‚o (rgba(56, 161, 105, 0.2))</li>
     *   <li><strong>SpÃ³Åºniony</strong> - pomaraÅ„czowe tÅ‚o (rgba(245, 101, 0, 0.2))</li>
     *   <li><strong>Nieobecny</strong> - czerwone tÅ‚o (rgba(229, 62, 62, 0.2))</li>
     *   <li><strong>Nie zaznaczono</strong> - szare tÅ‚o (rgba(108, 117, 125, 0.1))</li>
     * </ul>
     *
     * <p>Format nagÅ‚Ã³wkÃ³w kolumn terminÃ³w:</p>
     * <pre>
     * [Nazwa przedmiotu]
     * [dd.MM.yyyy HH:mm]
     * </pre>
     *
     * @see AttendanceReportRow
     * @see ClassSchedule#getAttendanceForStudent(Student)
     * @see Attendance.Status
     */
    private void generateReport() {
        reportData.clear();
        attendanceTable.getColumns().clear();

        // Dodaj podstawowe kolumny
        attendanceTable.getColumns().addAll(studentNameColumn, indexColumn);

        // Dodaj kolumny dla kaÅ¼dego terminu
        for (int i = 0; i < schedules.size(); i++) {
            ClassSchedule schedule = schedules.get(i);
            TableColumn<AttendanceReportRow, String> column = new TableColumn<>(
                    schedule.getSubject() + "\n" + schedule.getFormattedStartTime()
            );

            final int scheduleIndex = i;
            column.setCellValueFactory(data -> {
                AttendanceReportRow row = data.getValue();
                String status = row.getAttendanceForSchedule(scheduleIndex);
                return new javafx.beans.property.SimpleStringProperty(status);
            });

            // Stylizacja kolumn
            column.setCellFactory(col -> new TableCell<AttendanceReportRow, String>() {
                @Override
                protected void updateItem(String status, boolean empty) {
                    super.updateItem(status, empty);
                    if (empty || status == null) {
                        setText(null);
                        setStyle("");
                    } else {
                        setText(status);
                        switch (status) {
                            case "Obecny":
                                setStyle("-fx-background-color: rgba(56, 161, 105, 0.2); -fx-text-fill: #38A169;");
                                break;
                            case "SpÃ³Åºniony":
                                setStyle("-fx-background-color: rgba(245, 101, 0, 0.2); -fx-text-fill: #F56500;");
                                break;
                            case "Nieobecny":
                                setStyle("-fx-background-color: rgba(229, 62, 62, 0.2); -fx-text-fill: #E53E3E;");
                                break;
                            default:
                                setStyle("-fx-background-color: rgba(108, 117, 125, 0.1); -fx-text-fill: #6C757D;");
                        }
                    }
                }
            });

            attendanceTable.getColumns().add(column);
        }

        // Kolumna statystyk
        TableColumn<AttendanceReportRow, String> statsColumn = new TableColumn<>("Statystyki");
        statsColumn.setCellValueFactory(new PropertyValueFactory<>("statistics"));
        attendanceTable.getColumns().add(statsColumn);

        for (Student student : students) {
            AttendanceReportRow row = new AttendanceReportRow(student);

            // zbieranie obecnsoci dla terminu
            for (ClassSchedule schedule : schedules) {
                Attendance attendance = schedule.getAttendanceForStudent(student);
                if (attendance != null) {
                    row.addAttendance(attendance.getStatus().getDisplayName());
                } else {
                    row.addAttendance("Nie zaznaczono");
                }
            }

            row.calculateStatistics();
            reportData.add(row);
        }
    }

    /**
     * Oblicza i wyÅ›wietla statystyki frekwencji dla caÅ‚ej grupy.
     *
     * <p>Metoda analizuje dane obecnoÅ›ci wszystkich studentÃ³w i generuje
     * kluczowe wskaÅºniki frekwencji grupy. Statystyki sÄ… automatycznie
     * aktualizowane w interfejsie uÅ¼ytkownika.</p>
     *
     * <p>Obliczane statystyki:</p>
     * <ul>
     *   <li><strong>Åšrednia obecnoÅ›Ä‡</strong> - Å›redni procent obecnoÅ›ci wszystkich studentÃ³w</li>
     *   <li><strong>Najlepsza frekwencja</strong> - student z najwyÅ¼szym procentem obecnoÅ›ci</li>
     *   <li><strong>Najgorsza frekwencja</strong> - student z najniÅ¼szym procentem obecnoÅ›ci</li>
     * </ul>
     *
     * <p>Formatowanie wynikÃ³w:</p>
     * <ul>
     *   <li>Procenty wyÅ›wietlane z dokÅ‚adnoÅ›ciÄ… do 1 miejsca po przecinku</li>
     *   <li>Nazwy studentÃ³w w peÅ‚nym formacie (imiÄ™ + nazwisko)</li>
     *   <li>Graceful handling dla pustych danych</li>
     * </ul>
     *
     * <p>PrzykÅ‚ady formatÃ³w wyjÅ›ciowych:</p>
     * <pre>
     * "Åšrednia obecnoÅ›Ä‡: 87.5%"
     * "Najlepsza frekwencja: Jan Kowalski (95.2%)"
     * "Najgorsza frekwencja: Anna Nowak (72.1%)"
     * </pre>
     *
     * @see AttendanceReportRow#getAttendancePercentage()
     * @see #avgAttendanceLabel
     * @see #bestStudentLabel
     * @see #worstStudentLabel
     */
    private void calculateStatistics() {
        if (reportData.isEmpty()) {
            avgAttendanceLabel.setText("Åšrednia obecnoÅ›Ä‡: 0%");
            bestStudentLabel.setText("Najlepsza frekwencja: Brak danych");
            worstStudentLabel.setText("Najgorsza frekwencja: Brak danych");
            return;
        }

        double avgAttendance = reportData.stream()
                .mapToDouble(AttendanceReportRow::getAttendancePercentage)
                .average()
                .orElse(0.0);

        AttendanceReportRow bestStudent = reportData.stream()
                .max((a, b) -> Double.compare(a.getAttendancePercentage(), b.getAttendancePercentage()))
                .orElse(null);

        AttendanceReportRow worstStudent = reportData.stream()
                .min((a, b) -> Double.compare(a.getAttendancePercentage(), b.getAttendancePercentage()))
                .orElse(null);

        avgAttendanceLabel.setText(String.format("Åšrednia obecnoÅ›Ä‡: %.1f%%", avgAttendance));

        if (bestStudent != null) {
            bestStudentLabel.setText(String.format("Najlepsza frekwencja: %s (%.1f%%)",
                    bestStudent.getStudentName(), bestStudent.getAttendancePercentage()));
        }

        if (worstStudent != null) {
            worstStudentLabel.setText(String.format("Najgorsza frekwencja: %s (%.1f%%)",
                    worstStudent.getStudentName(), worstStudent.getAttendancePercentage()));
        }
    }

    /**
     * Stosuje filtry do danych raportu na podstawie wybranych opcji.
     *
     * <p>Metoda filtruje dane w tabeli wedÅ‚ug wybranych kryteriÃ³w w ComboBox-ach.
     * Implementacja filtrowania zostanie dodana w przyszÅ‚ej wersji - obecnie
     * jest to metoda placeholder.</p>
     *
     * <p>Planowane filtry:</p>
     * <ul>
     *   <li><strong>Filtr terminÃ³w</strong> - pokazywanie tylko wybranego terminu</li>
     *   <li><strong>Filtr statusÃ³w</strong> - pokazywanie tylko okreÅ›lonych statusÃ³w obecnoÅ›ci</li>
     * </ul>
     *
     * @see #filterScheduleComboBox
     * @see #filterTypeComboBox
     * @see AttendanceFilter
     */
    private void applyFilters() {
        // TODO: Implementuj filtrowanie danych
        // Na podstawie wybranego terminu i typu filtru
    }

    /**
     * Eksportuje dziennik obecnoÅ›ci do pliku CSV.
     *
     * <p>Otwiera dialog wyboru pliku i zapisuje kompletnÄ… tabelÄ™ obecnoÅ›ci
     * w formacie CSV, zachowujÄ…c wszystkie kolumny i formatowanie danych.
     * Plik moÅ¼e byÄ‡ pÃ³Åºniej otwarty w Excel lub innych programach arkuszowych.</p>
     *
     * <p>Struktura eksportowanego pliku CSV:</p>
     * <ol>
     *   <li><strong>NagÅ‚Ã³wki</strong> - nazwy kolumn oddzielone przecinkami</li>
     *   <li><strong>Dane studentÃ³w</strong> - jeden wiersz na studenta</li>
     *   <li><strong>Kolumny terminÃ³w</strong> - statusy obecnoÅ›ci dla kaÅ¼dego terminu</li>
     *   <li><strong>Statystyki</strong> - podsumowanie dla kaÅ¼dego studenta</li>
     * </ol>
     *
     * <p>Format nazwy pliku:</p>
     * <pre>dziennik_obecnosci_[nazwa_grupy].csv</pre>
     *
     * <p>PrzykÅ‚ad struktury CSV:</p>
     * <pre>
     * ImiÄ™ i nazwisko,Numer indeksu,Egzamin Java (15.10.2024),Laboratorium (22.10.2024),Statystyki
     * Jan Kowalski,123456,Obecny,SpÃ³Åºniony,"85.5% (17/20)"
     * Anna Nowak,654321,Nieobecny,Obecny,"72.1% (13/18)"
     * </pre>
     *
     * <p>ObsÅ‚uga bÅ‚Ä™dÃ³w:</p>
     * <ul>
     *   <li>Dialog anulowania przez uÅ¼ytkownika</li>
     *   <li>BÅ‚Ä™dy zapisu pliku (brak uprawnieÅ„, brak miejsca na dysku)</li>
     *   <li>Problemy z kodowaniem znakÃ³w</li>
     * </ul>
     *
     * @see FileChooser
     * @see #currentGroup
     * @see #schedules
     * @see #reportData
     */
    @FXML
    private void exportToCSV() {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Zapisz dziennik obecnoÅ›ci");
        fileChooser.getExtensionFilters().add(
                new FileChooser.ExtensionFilter("CSV files (*.csv)", "*.csv")
        );
        fileChooser.setInitialFileName("dziennik_obecnosci_" + currentGroup.getName() + ".csv");

        Stage stage = (Stage) exportCSVButton.getScene().getWindow();
        File file = fileChooser.showSaveDialog(stage);

        if (file != null) {
            try (FileWriter writer = new FileWriter(file)) {
                // NagÅ‚Ã³wki CSV
                writer.append("ImiÄ™ i nazwisko,Numer indeksu");
                for (ClassSchedule schedule : schedules) {
                    writer.append(",").append(schedule.getSubject()).append(" (")
                            .append(schedule.getFormattedStartTime()).append(")");
                }
                writer.append(",Statystyki\n");

                // Dane studentÃ³w
                for (AttendanceReportRow row : reportData) {
                    writer.append(row.getStudentName()).append(",")
                            .append(row.getIndexNumber());

                    for (int i = 0; i < schedules.size(); i++) {
                        writer.append(",").append(row.getAttendanceForSchedule(i));
                    }

                    writer.append(",").append(row.getStatistics()).append("\n");
                }

                showAlert("Sukces", "Dziennik zostaÅ‚ wyeksportowany do pliku:\n" + file.getAbsolutePath(),
                        Alert.AlertType.INFORMATION);

            } catch (Exception e) {
                showAlert("BÅ‚Ä…d", "Nie udaÅ‚o siÄ™ zapisaÄ‡ pliku:\n" + e.getMessage(),
                        Alert.AlertType.ERROR);
            }
        }
    }

    /**
     * OdÅ›wieÅ¼a raport obecnoÅ›ci, regenerujÄ…c tabelÄ™ i statystyki.
     *
     * <p>Ponownie generuje caÅ‚Ä… tabelÄ™ obecnoÅ›ci i przelicza wszystkie statystyki
     * na podstawie aktualnych danych. Przydatne gdy dane mogÅ‚y siÄ™ zmieniÄ‡
     * od momentu wygenerowania raportu.</p>
     *
     * @see #generateReport()
     * @see #calculateStatistics()
     */
    @FXML
    private void refreshReport() {
        generateReport();
        calculateStatistics();
        showAlert("Info", "Raport zostaÅ‚ odÅ›wieÅ¼ony", Alert.AlertType.INFORMATION);
    }

    /**
     * Zamyka okno dziennika obecnoÅ›ci.
     *
     * <p>Pobiera referencjÄ™ do aktualnego Stage i zamyka okno raportu,
     * powracajÄ…c do kontrolera nadrzÄ™dnego.</p>
     */
    @FXML
    private void closeWindow() {
        Stage stage = (Stage) closeButton.getScene().getWindow();
        stage.close();
    }

    /**
     * WyÅ›wietla dialog z komunikatem dla uÅ¼ytkownika.
     *
     * <p>Uniwersalna metoda do pokazywania alertÃ³w o rÃ³Å¼nych typach
     * (informacja, ostrzeÅ¼enie, bÅ‚Ä…d). Automatycznie stylizuje dialog
     * zgodnie z motywem aplikacji.</p>
     *
     * @param title tytuÅ‚ okna dialogowego
     * @param message treÅ›Ä‡ komunikatu do wyÅ›wietlenia
     * @param type typ alertu (INFORMATION, WARNING, ERROR, etc.)
     *
     * @see Alert.AlertType
     */
    private void showAlert(String title, String message, Alert.AlertType type) {
        Alert alert = new Alert(type);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }

    /**
     * Klasa reprezentujÄ…ca wiersz w tabeli raportu obecnoÅ›ci.
     *
     * <p>AttendanceReportRow agreguje dane jednego studenta wraz z jego obecnoÅ›ciami
     * na wszystkich terminach oraz obliczonymi statystykami frekwencji. KaÅ¼dy wiersz
     * w tabeli raportu jest reprezentowany przez instancjÄ™ tej klasy.</p>
     *
     * <p>Klasa zarzÄ…dza nastÄ™pujÄ…cymi danymi:</p>
     * <ul>
     *   <li><strong>Dane studenta</strong> - imiÄ™, nazwisko, numer indeksu</li>
     *   <li><strong>Lista obecnoÅ›ci</strong> - statusy dla kaÅ¼dego terminu w kolejnoÅ›ci</li>
     *   <li><strong>Statystyki</strong> - obliczony procent obecnoÅ›ci i podsumowanie</li>
     * </ul>
     *
     * <p>Statystyki sÄ… obliczane automatycznie przez {@link #calculateStatistics()}
     * i uwzglÄ™dniajÄ… nastÄ™pujÄ…ce zasady:</p>
     * <ul>
     *   <li><strong>Obecni i spÃ³Åºnieni</strong> liczÄ… siÄ™ jako pozytywne dla frekwencji</li>
     *   <li><strong>Nieobecni</strong> liczÄ… siÄ™ jako negatywne dla frekwencji</li>
     *   <li><strong>"Nie zaznaczono"</strong> nie sÄ… uwzglÄ™dniane w obliczeniach</li>
     * </ul>
     *
     * <h3>PrzykÅ‚ad uÅ¼ycia:</h3>
     * <pre>
     * {@code
     * AttendanceReportRow row = new AttendanceReportRow(student);
     *
     * // Dodawanie obecnoÅ›ci dla kaÅ¼dego terminu
     * row.addAttendance("Obecny");
     * row.addAttendance("SpÃ³Åºniony");
     * row.addAttendance("Nieobecny");
     * row.addAttendance("Nie zaznaczono");
     *
     * // Obliczenie statystyk
     * row.calculateStatistics();
     *
     * // Wynik: "66.7% (2/3)" - 2 z 3 ocenionych obecnoÅ›ci
     * System.out.println(row.getStatistics());
     * }
     * </pre>
     *
     * @see Student
     * @see Attendance.Status
     * @see #generateReport()
     */
    public static class AttendanceReportRow {

        /**
         * Student, ktÃ³rego dotyczy ten wiersz raportu.
         */
        private final Student student;

        /**
         * Lista statusÃ³w obecnoÅ›ci dla kaÅ¼dego terminu w kolejnoÅ›ci chronologicznej.
         *
         * <p>KolejnoÅ›Ä‡ statusÃ³w odpowiada kolejnoÅ›ci terminÃ³w w {@link #schedules}.
         * MoÅ¼liwe wartoÅ›ci: "Obecny", "SpÃ³Åºniony", "Nieobecny", "Nie zaznaczono".</p>
         */
        private final List<String> attendanceStatuses = new java.util.ArrayList<>();

        /**
         * Obliczone statystyki frekwencji studenta w formacie tekstowym.
         *
         * <p>Format: "X.X% (obecni+spÃ³Åºnieni/Å‚Ä…cznie_ocenione)"</p>
         * <p>PrzykÅ‚ad: "85.5% (17/20)"</p>
         */
        private String statistics = "";

        /**
         * Konstruktor wiersza raportu dla konkretnego studenta.
         *
         * @param student student dla tego wiersza (nie moÅ¼e byÄ‡ null)
         * @throws IllegalArgumentException jeÅ›li student jest null
         */
        public AttendanceReportRow(Student student) {
            this.student = student;
        }

        /**
         * Dodaje status obecnoÅ›ci dla kolejnego terminu.
         *
         * <p>Statusy sÄ… dodawane w kolejnoÅ›ci chronologicznej terminÃ³w.
         * Metoda nie waliduje wartoÅ›ci - przyjmuje dowolny string.</p>
         *
         * @param status status obecnoÅ›ci jako String (np. "Obecny", "Nieobecny")
         */
        public void addAttendance(String status) {
            attendanceStatuses.add(status);
        }

        /**
         * Oblicza statystyki frekwencji dla studenta na podstawie dodanych obecnoÅ›ci.
         *
         * <p>Metoda analizuje wszystkie statusy obecnoÅ›ci i generuje podsumowanie
         * w formacie czytelnym dla uÅ¼ytkownika. Obliczenia uwzglÄ™dniajÄ… tylko
         * terminy, gdzie obecnoÅ›Ä‡ zostaÅ‚a oznaczona (pomija "Nie zaznaczono").</p>
         *
         * <p>Algorytm obliczania:</p>
         * <ol>
         *   <li>Zlicz obecnych i spÃ³Åºnionych (pozytywne obecnoÅ›ci)</li>
         *   <li>Zlicz nieobecnych (negatywne obecnoÅ›ci)</li>
         *   <li>Oblicz Å‚Ä…cznÄ… liczbÄ™ ocenionych terminÃ³w (bez "Nie zaznaczono")</li>
         *   <li>Wylicz procent: (pozytywne / Å‚Ä…cznie) * 100</li>
         *   <li>Sformatuj wynik z dokÅ‚adnoÅ›ciÄ… do 1 miejsca po przecinku</li>
         * </ol>
         *
         * <p>PrzykÅ‚ady wynikÃ³w:</p>
         * <ul>
         *   <li>"100.0% (5/5)" - perfect attendance</li>
         *   <li>"80.0% (4/5)" - jedna nieobecnoÅ›Ä‡</li>
         *   <li>"66.7% (2/3)" - dwie obecnoÅ›ci z trzech ocenionych</li>
         *   <li>"Brak danych" - brak ocenionych terminÃ³w</li>
         *   <li>"Brak ocen" - wszystkie terminy "Nie zaznaczono"</li>
         * </ul>
         *
         * @see #getAttendancePercentage()
         * @see #getStatistics()
         */
        public void calculateStatistics() {
            if (attendanceStatuses.isEmpty()) {
                statistics = "Brak danych";
                return;
            }

            long present = attendanceStatuses.stream().filter(s -> s.equals("Obecny")).count();
            long late = attendanceStatuses.stream().filter(s -> s.equals("SpÃ³Åºniony")).count();
            long absent = attendanceStatuses.stream().filter(s -> s.equals("Nieobecny")).count();
            long total = present + late + absent;

            if (total == 0) {
                statistics = "Brak ocen";
            } else {
                double percentage = (double) (present + late) / total * 100;
                statistics = String.format("%.1f%% (%d/%d)", percentage, present + late, total);
            }
        }

        /**
         * Zwraca procentowÄ… frekwencjÄ™ studenta jako liczbÄ™.
         *
         * <p>Metoda oblicza procent obecnoÅ›ci (wÅ‚Ä…czajÄ…c spÃ³Åºnionych) w stosunku
         * do wszystkich ocenionych terminÃ³w. WartoÅ›Ä‡ jest zwracana jako double
         * w zakresie 0.0-100.0.</p>
         *
         * <p>UÅ¼ycie w obliczeniach statystycznych:</p>
         * <ul>
         *   <li>Åšrednia frekwencji grupy</li>
         *   <li>Ranking studentÃ³w wedÅ‚ug frekwencji</li>
         *   <li>Identyfikacja najlepszego/najgorszego studenta</li>
         * </ul>
         *
         * @return procent obecnoÅ›ci (0.0-100.0), lub 0.0 jeÅ›li brak danych
         *
         * @see #calculateStatistics()
         */
        public double getAttendancePercentage() {
            if (attendanceStatuses.isEmpty()) return 0.0;

            long present = attendanceStatuses.stream().filter(s -> s.equals("Obecny")).count();
            long late = attendanceStatuses.stream().filter(s -> s.equals("SpÃ³Åºniony")).count();
            long total = attendanceStatuses.stream().filter(s -> !s.equals("Nie zaznaczono")).count();

            if (total == 0) return 0.0;
            return (double) (present + late) / total * 100;
        }

        /**
         * Zwraca peÅ‚ne imiÄ™ i nazwisko studenta.
         *
         * <p>Wykorzystywane jako wartoÅ›Ä‡ dla kolumny "ImiÄ™ i nazwisko" w tabeli raportu.</p>
         *
         * @return peÅ‚ne imiÄ™ studenta w formacie "ImiÄ™ Nazwisko"
         *
         * @see Student#getFullName()
         * @see #studentNameColumn
         */
        public String getStudentName() {
            return student.getFullName();
        }

        /**
         * Zwraca numer indeksu studenta.
         *
         * <p>Wykorzystywane jako wartoÅ›Ä‡ dla kolumny "Nr indeksu" w tabeli raportu.</p>
         *
         * @return numer indeksu studenta (6 cyfr)
         *
         * @see Student#getIndexNumber()
         * @see #indexColumn
         */
        public String getIndexNumber() {
            return student.getIndexNumber();
        }

        /**
         * Zwraca obliczone statystyki frekwencji jako sformatowany tekst.
         *
         * <p>Wykorzystywane jako wartoÅ›Ä‡ dla kolumny "Statystyki" w tabeli raportu.
         * Statystyki muszÄ… byÄ‡ wczeÅ›niej obliczone przez {@link #calculateStatistics()}.</p>
         *
         * @return statystyki w formacie "X.X% (Y/Z)" lub komunikat o braku danych
         *
         * @see #calculateStatistics()
         */
        public String getStatistics() {
            return statistics;
        }

        /**
         * Zwraca status obecnoÅ›ci dla konkretnego terminu (kolumny).
         *
         * <p>Metoda uÅ¼ywana przez dynamiczne kolumny terminÃ³w w tabeli do pobierania
         * wartoÅ›ci komÃ³rek. Indeks odpowiada pozycji terminu na liÅ›cie schedules.</p>
         *
         * @param index indeks terminu (0-based)
         * @return status obecnoÅ›ci dla tego terminu lub "Nie zaznaczono" jeÅ›li brak danych
         *
         * @see #generateReport()
         * @see #addAttendance(String)
         */
        public String getAttendanceForSchedule(int index) {
            if (index >= 0 && index < attendanceStatuses.size()) {
                return attendanceStatuses.get(index);
            }
            return "Nie zaznaczono";
        }
    }
}